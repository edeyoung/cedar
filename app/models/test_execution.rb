# Test executions are the main object in Cedar, set up by the user to
# drive the generation of specific QRDA documents
class TestExecution
  include Mongoid::Document
  include Mongoid::Timestamps::Created
  include Mongoid::Timestamps::Updated
  include GlobalID::Identification

  field :state,               type: Symbol,  default: :incomplete  # incomplete, passed, failed
  field :step,                type: Symbol,  default: :details     # see StepsController
  field :wizard_progress,     type: Float,   default: 0            # 0 to 100
  field :qrda_progress,       type: Float,   default: 0            # 0 to 100
  field :name,                type: String,  default: ''
  field :description,         type: String,  default: ''
  field :reporting_period,    type: String,  default: ''
  field :qrda_type,           type: String,  default: nil          # 1 or 3
  field :results,             type: Hash,    default: { passed: 0, total: 0 }
  field :disable_details,     type: Boolean, default: false
  field :file_path,           type: String,  default: ''

  has_and_belongs_to_many :measures
  has_and_belongs_to_many :validations
  has_many                :documents,
                          inverse_of: :test_execution,
                          dependent: :destroy,
                          order: 'name ASC'
  belongs_to              :user

  accepts_nested_attributes_for :documents

  scope :order_by_date, -> { order_by(created_at: :desc) }
  scope :order_by_name, -> { order_by(name: :asc) }
  scope :order_by_state, -> { order_by(state: :asc) }
  scope :state, -> (state) { where state: state }
  scope :user, -> (user) { where user_id: user }

  # When we've gathered enough information, create the QRDA document package
  # First, disable all of the detail fields so dupe documents cannot be created
  # Then, generate a new document for each validation and a few acceptable docs
  # When all documents are created, zip them up and serve them to the file system
  # Finally, clean up any unnecessary patient records generated by the process
  def create_documents
    if qrda_progress == 0
      self.disable_details = true
      @documents_to_generate = validation_ids.count + 2
      @current_document = 1
      generate_invalid_qrda_text
      generate_valid_qrda_text
      zip_qrda_files
      HealthDataStandards::CQM::PatientCache.where('value.test_id'.to_sym.ne => nil).destroy_all
      HealthDataStandards::CQM::QueryCache.where('value.test_id'.to_sym.exists => true).destroy_all
    end
  end

  # FIXME: There is a bunch of duplicated code in the next two methods
  # For each chosen validation, generate one or two invalid qrda documents
  def generate_invalid_qrda_text
    validation_ids.each do |validation_id|
      Random.new.rand(1..2).times do
        measure = HealthDataStandards::CQM::Measure.find_by(_id: measure_ids.sample)
        doc = Document.create(
          name: Faker::Company.name,
          validation_id: validation_id,
          test_execution: self,
          measure_id: measure.hqmf_id,
          qrda: generate_qrda_text(measure)
        )
        Cedar::Invalidator.invalidate_qrda(doc)
      end
      @current_document += 1
      update_attribute(:qrda_progress, 100 * @current_document / @documents_to_generate)
    end
  end

  # To prevent teaching to the test, generate some totally valid qrda documents
  def generate_valid_qrda_text
    Random.new.rand(1..4).times do
      measure = HealthDataStandards::CQM::Measure.find_by(_id: measure_ids.sample)
      Document.create(
        name: Faker::Company.name,
        expected_result: :accept,
        test_execution: self,
        measure_id: measure.hqmf_id,
        qrda: generate_qrda_text(measure)
      )
    end
    @current_document += 1
    update_attribute(:qrda_progress, 100 * @current_document / @documents_to_generate)
  end

  # Use a random measure ID from the test_execution list of measure ids
  # Take the one bundle object from the db
  # Array of patient record objects found from the patient cache for the particular measure
  def generate_qrda_text(measure)
    measure_id = measure['hqmf_id']
    start_date = DateTime.new(reporting_period.to_i, 1, 1).utc
    end_date = start_date.years_since(1) - 1
    bundle = self.bundle
    patient_records = HealthDataStandards::CQM::PatientCache.where('value.measure_id' => measure_id, 'value.test_id' => nil).to_a.map(&:record)
    if qrda_type == '3' # TODO: We could potentially create a Cat 3 file without creating Cat 1 files
      zip = Cypress::CreateDownloadZip.create_zip(patient_records, 'qrda', measure, start_date, end_date)
      c3c = Cypress::Cat3Calculator.new([measure_id], bundle)
      c3c.import_cat1_zip(zip)
      c3c.generate_cat3(start_date, end_date)
    elsif qrda_type == '1'
      formatter = Cypress::QRDAExporter.new([measure], start_date, end_date)
      patient = patient_records.sample
      formatter.export(patient)
    else
      raise 'Unknown QRDA type'
    end
  end

  # Find the bundle that corresponds to the reporting_period
  def bundle
    HealthDataStandards::CQM::Bundle.find_by measure_period_start: BUNDLE_MAP[reporting_period]
  end

  # Zip all the qrda files associated with a given test execution
  def zip_qrda_files
    file_name = name.gsub(/[^0-9A-Za-z]/, '_')
    update_attribute(:file_path, "data/#{file_name}.zip")
    Zip::ZipOutputStream.open('public/' + file_path) do |zip|
      document_ids.each do |document_id|
        doc = Document.find(document_id)
        zip.put_next_entry("#{doc.name}.xml")
        zip << doc.qrda
      end
    end
  end

  # Assume that the test_execution passed, loop through all of its documents,
  # and fail it if the expected and actual results don't match
  def set_overview_state
    pass_test = true
    passed_validations = 0
    total_validations = 0
    document_ids.each do |document|
      doc = Document.find(document)
      total_validations += 1
      if doc.expected_result != doc.actual_result
        pass_test = false
        doc.update_attribute(:state, :failed)
      else
        doc.update_attribute(:state, :passed)
        passed_validations += 1
      end
    end
    pass_test ? update_attribute(:state, :passed) : update_attribute(:state, :failed)
    update_attribute(:results, passed: passed_validations, total: total_validations)
  end

  # Allow for test_execution copying without associated qrda documents
  def dup_test
    duplicate = dup
    duplicate.update_attributes(
      state: :incomplete,
      step: :details,
      wizard_progress: 0,
      qrda_progress: 0,
      results: { passed: 0, total: 0 },
      disable_details: false,
      file_path: ''
    )
    duplicate.save
    duplicate
  end
end
